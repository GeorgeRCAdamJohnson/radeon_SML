{
  "title": "General-purpose computing on graphics processing units",
  "summary": "General-purpose computing on graphics processing units is the use of a graphics processing unit (GPU), which typically handles computation only for computer graphics, to perform computation in applications traditionally handled by the central processing unit (CPU). The use of multiple video cards in one computer, or large numbers of graphics chips, further parallelizes the already parallel nature of graphics processing.",
  "content": "General-purpose computing on graphics processing units Use of a GPU for computations typically assigned to CPUs .mw-parser-output .ambox{border:1px solid #a2a9b1;border-left:10px solid #36c;background-color:#fbfbfb;box-sizing:border-box}.mw-parser-output .ambox+link+.ambox,.mw-parser-output .ambox+link+style+.ambox,.mw-parser-output .ambox+link+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+style+.ambox,.mw-parser-output .ambox+.mw-empty-elt+link+link+.ambox{margin-top:-1px}html body.mediawiki .mw-parser-output .ambox.mbox-small-left{margin:4px 1em 4px 0;overflow:hidden;width:238px;border-collapse:collapse;font-size:88%;line-height:1.25em}.mw-parser-output .ambox-speedy{border-left:10px solid #b32424;background-color:#fee7e6}.mw-parser-output .ambox-delete{border-left:10px solid #b32424}.mw-parser-output .ambox-content{border-left:10px solid #f28500}.mw-parser-output .ambox-style{border-left:10px solid #fc3}.mw-parser-output .ambox-move{border-left:10px solid #9932cc}.mw-parser-output .ambox-protection{border-left:10px solid #a2a9b1}.mw-parser-output .ambox .mbox-text{border:none;padding:0.25em 0.5em;width:100%}.mw-parser-output .ambox .mbox-image{border:none;padding:2px 0 2px 0.5em;text-align:center}.mw-parser-output .ambox .mbox-imageright{border:none;padding:2px 0.5em 2px 0;text-align:center}.mw-parser-output .ambox .mbox-empty-cell{border:none;padding:0;width:1px}.mw-parser-output .ambox .mbox-image-div{width:52px}@media(min-width:720px){.mw-parser-output .ambox{margin:0 10%}}@media print{body.ns-0 .mw-parser-output .ambox{display:none!important}} This article needs additional citations for verification . Please help improve this article by adding citations to reliable sources . Unsourced material may be challenged and removed. Find sources: \"General-purpose computing on graphics processing units\" – news · newspapers · books · scholar · JSTOR ( February 2022 ) ( Learn how and when to remove this message ) General-purpose computing on graphics processing units ( GPGPU , or less often GPGP ) is the use of a graphics processing unit (GPU), which typically handles computation only for computer graphics , to perform computation in applications traditionally handled by the central processing unit (CPU). [ 1 ] [ 2 ] [ 3 ] [ 4 ] The use of multiple video cards in one computer, or large numbers of graphics chips, further parallelizes the already parallel nature of graphics processing. [ 5 ] Essentially, a GPGPU pipeline is a kind of parallel processing between one or more GPUs and CPUs, with special accelerated instructions for processing image or other graphic forms of data. While GPUs operate at lower frequencies, they typically have many times the number of Processing elements . Thus, GPUs can process far more pictures and other graphical data per second than a traditional CPU. Migrating data into parallel form and then using the GPU to process it can (theoretically) create a large speedup . GPGPU pipelines were developed at the beginning of the 21st century for graphics processing (e.g. for better shaders ). From the history of supercomputing it is well-known that scientific computing drives the largest concentrations of Computing power in history, listed in the TOP500 : the majority today utilize GPUs . The best-known GPGPUs are Nvidia Tesla that are used for Nvidia DGX , alongside AMD Instinct and Intel Gaudi. History In principle, any arbitrary Boolean function , including addition, multiplication, and other mathematical functions, can be built up from a functionally complete set of logic operators. In 1987, Conway's Game of Life became one of the first examples of general-purpose computing using an early stream processor called a blitter to invoke a special sequence of logical operations on bit vectors. [ 6 ] General-purpose computing on GPUs became more practical and popular after about 2001, with the advent of both programmable shaders and floating point support on graphics processors. Notably, problems involving matrices and/or vectors – especially two-, three-, or four-dimensional vectors – were easy to translate to a GPU, which acts with native speed and support on those types. A significant milestone for GPGPU was the year 2003 when two research groups independently discovered GPU-based approaches for the solution of general linear algebra problems on GPUs that ran faster than on CPUs. [ 7 ] [ 8 ] These early efforts to use GPUs as general-purpose processors required reformulating computational problems in terms of graphics primitives, as supported by the two major APIs for graphics processors, OpenGL and DirectX . This cumbersome translation was obviated by the advent of general-purpose programming languages and APIs such as Sh / RapidMind , Brook and Accelerator. [ 9 ] [ 10 ] [ 11 ] These were followed by Nvidia's CUDA , which allowed programmers to ignore the underlying graphical concepts in favor of more common high-performance computing concepts. [ 12 ] Newer, hardware-vendor-independent offerings include Microsoft's DirectCompute and Apple/Khronos Group's OpenCL . [ 12 ] This means that modern GPGPU pipelines can leverage the speed of a GPU without requiring full and explicit conversion of the data to a graphical form. Mark Harris, the founder of GPGPU.org, claims he coined the term GPGPU . [ 13 ] Implementations Software libraries and APIs Any language that allows the code running on the CPU to poll a GPU shader for return values, can create a GPGPU framework. Programming standards for parallel computing include OpenCL (vendor-independent), OpenACC , OpenMP and OpenHMPP . As of 2016 [ update ] , OpenCL is the dominant open general-purpose GPU computing language, and is an open standard defined by the Khronos Group . [ citation needed ] OpenCL provides a cross-platform GPGPU platform that additionally supports data parallel compute on CPUs. OpenCL is actively supported on Intel, AMD, Nvidia, and ARM platforms. The Khronos Group has also standardised and implemented SYCL , a higher-level programming model for OpenCL as a single-source domain specific embedded language based on pure C++11. The dominant proprietary framework is Nvidia CUDA . [ 14 ] Nvidia launched CUDA in 2006, a software development kit (SDK) and application programming interface (API) that allows using the programming language C to code algorithms for execution on GeForce 8 series and later GPUs. ROCm , launched in 2016, is AMD's open-source response to CUDA. It is, as of 2022, on par with CUDA with regards to features, [ citation needed ] and still lacking in consumer support. [ citation needed ] OpenVIDIA was developed at University of Toronto between 2003–2005, [ 15 ] in collaboration with Nvidia. Altimesh Hybridizer created by Altimesh compiles Common Intermediate Language to CUDA binaries. [ 16 ] [ 17 ] It supports generics and virtual functions. [ 18 ] Debugging and profiling is integrated with Visual Studio and Nsight. [ 19 ] It is available as a Visual Studio extension on Visual Studio Marketplace. Microsoft introduced the DirectCompute GPU computing API, released with the DirectX 11 API. .mw-parser-output .vanchor>:target~.vanchor-text{background-color:#b1d2ff}@media screen{html.skin-theme-clientpref-night .mw-parser-output .vanchor>:target~.vanchor-text{background-color:#0f4dc9}}@media screen and (prefers-color-scheme:dark){html.skin-theme-clientpref-os .mw-parser-output .vanchor>:target~.vanchor-text{background-color:#0f4dc9}} Alea GPU , [ 20 ] created by QuantAlea, [ 21 ] introduces native GPU computing capabilities for the Microsoft .NET languages F# [ 22 ] and C# . Alea GPU also provides a simplified GPU programming model based on GPU parallel-for and parallel aggregate using delegates and automatic memory management. [ 23 ] MATLAB supports GPGPU acceleration using the Parallel Computing Toolbox and MATLAB Distributed Computing Server , [ 24 ] and third-party packages like Jacket . GPGPU processing is also used to simulate Newtonian physics by physics engines , [ 25 ] and commercial implementations include Havok Physics, FX and PhysX , both of which are typically used for computer and video games . C++ Accelerated Massive Parallelism ( C++ AMP ) is a library that accelerates execution of C++ code by exploiting the data-parallel hardware on GPUs. Mobile computers Due to a trend of increasing power of mobile GPUs, general-purpose programming became available also on the mobile devices running major mobile operating systems . Google Android 4.2 enabled running RenderScript code on the mobile device GPU. [ 26 ] Renderscript has since been deprecated in favour of first OpenGL compute shaders [ 27 ] and later Vulkan Compute. [ 28 ] OpenCL is available on many Android devices, but is not officially supported by Android. [ 29 ] Apple introduced the proprietary Metal API for iOS applications, able to execute arbitrary code through Apple's GPU compute shaders. [ citation needed ] GPU vs. CPU This section possibly contains original research . Please improve it by verifying the claims made and adding inline citations . Statements consisting only of original research should be removed. ( February 2015 ) ( Learn how and when to remove this message ) This section does not cite any sources . Please help improve this section by adding citations to reliable sources . Unsourced material may be challenged and removed . ( July 2017 ) ( Learn how and when to remove this message ) Originally, data was simply passed one-way from a central processing unit (CPU) to a graphics processing unit (GPU), then to a display device . As time progressed, however, it became valuable for GPUs to store at first simple, then complex structures of data to be passed back to the CPU that analyzed an image, or a set of scientific-data represented as a 2D or 3D format that a video card can understand. Because the GPU has access to every draw operation, it can analyze data in these forms quickly, whereas a CPU must poll every pixel or data element much more slowly, as the speed of access between a CPU and its larger pool of random-access memory (or in an even worse case, a hard drive ) is slower than GPUs and video cards, which typically contain smaller amounts of more expensive memory that is much faster to access. Transferring the portion of the data set to be actively analyzed to that GPU memory in the form of textures or other easily readable GPU forms results in speed increase. The distinguishing feature of a GPGPU design is the ability to transfer information bidirectionally back from the GPU to the CPU; generally the data throughput in both directions is ideally high, resulting in a multiplier effect on the speed of a specific high-use algorithm . GPGPU pipelines may improve efficiency on especially large data sets and/or data containing 2D or 3D imagery. It is used in complex graphics pipelines as well as scientific computing ; more so in fields with large data sets like genome mapping , or where two- or three-dimensional analysis is useful – especially at present biomolecule analysis, protein study, and other complex organic chemistry . An example of such applications is NVIDIA software suite for genome analysis . Such pipelines can also vastly improve efficiency in image processing and computer vision , among other fields; as well as parallel processing generally. Some very heavily optimized pipelines have yielded speed increases of several hundred times the original CPU-based pipeline on one high-use task. A simple example would be a GPU program that collects data about average lighting values as it renders some view from either a camera or a computer graphics program back to the main program on the CPU, so that the CPU can then make adjustments to the overall screen view. A more advanced example might use edge detection to return both numerical information and a processed image representing outlines to a computer vision program controlling, say, a mobile robot. Because the GPU has fast and local hardware access to every pixel or other picture element in an image, it can analyze and average it (for the first example) or apply a Sobel edge filter or other convolution filter (for the second) with much greater speed than a CPU, which typically must access slower random-access memory copies of the graphic in question. GPGPU as a software concept is a type of algorithm , not a piece of equipment. Specialized equipment designs may, however, even further enhance the efficiency of GPGPU pipelines, which traditionally perform relatively few algorithms on very large amounts of data. Massively parallelized, gigantic-data-level tasks thus may be parallelized even further via specialized setups such as rack computing (many similar, highly tailored machines built into a rack ), which adds a third layer – many computing units each using many CPUs to correspond to many GPUs. Some Bitcoin \"miners\" used such setups for high-quantity processing. Insights into the largest such systems in the world has been maintained at the TOP500 supercomputer list. Caches Historically, CPUs have used hardware-managed caches , but the earlier GPUs only provided software-managed local memories. However, as GPUs are being increasingly used for general-purpose applications, state-of-the-art GPUs are being designed with hardware-managed multi-level caches which have helped the GPUs to move towards mainstream computing. For example, GeForce 200 series GT200 architecture GPUs did not feature an L2 cache, the Fermi GPU has 768 KiB last-level cache, the Kepler GPU has 1.5 MiB last-level cache, [ 30 ] the Maxwell GPU has 2 MiB last-level cache, and the Pascal GPU has 4 MiB last-level cache. Register file GPUs have very large register files , which allow them to reduce context-switching latency. Register file size is also increasing over different GPU generations, e.g., the total register file size on Maxwell (GM200), Pascal and Volta GPUs are 6 MiB, 14 MiB and 20 MiB, respectively. [ 31 ] [ 32 ] By comparison, the size of a register file on CPUs is small, typically tens or hundreds of kilobytes. In essence: almost all GPU workloads are inherently massively-parallel LOAD-COMPUTE-STORE in nature, such as Tiled rendering . Even storing one temporary vector for further recall (LOAD-COMPUTE-STORE-COMPUTE-LOAD-COMPUTE-STORE) is so expensive due to the Memory wall problem that it is to be avoided at all costs. [ 33 ] The result is that register file size has to increase. In standard CPUs it is possible to introduce caches (a D-cache ) to solve this problem, however these are relativrly so large that they are impractical to introduce in GPUs which would need one per Processing Element. ILLIAC IV innovatively solved the problem around 1967 by introducing a local memory per Processing Element (a PEM): a strategy copied by the Aspex ASP . Execution resources GPGPUs differ greatly from each other in how much execution resources is assigned to each group of \"cores\" that performs a stream of operations, variously called a \"streaming multiprocessor\" (SM) by Nvidia, compute unit (CU) or workgroup processor (WGP) by AMD according to the microarchitecture, \"Xe Core\" by Intel, all designed to perform what is called a \"work-group\" by OpenCL . [ 34 ] Much like how CPUs may elect to implement wider vector instructions in smaller pieces (e.g. AMD Bulldozer supported the 256-bit AVX instructions by splitting them into two 128-bit operations) to save power and/or chip area, [ 35 ] GPU designers also vary the amount of execution units to fit their expected workloads. On a GPGPU, each of the following resources can vary freely in ratio from the others: FP64 (FMA), FP32 (FMA), FP16 (FMA), Int32 Add, Int32 Mul, RCP/RSQRT. (An example can be seen in Nvidia's documentation about the execution resources found in each SM of different generation (compute capacity) of GPUs. Non-matrix FP16 is handled by the FP32 cores. [ 36 ] ) GPGPUs intended for scientific computing often have higher investment into FP64, while those designed for deep learning tends to have higher investment into FP16, lower-bitwidth \"packed\" integer operations, and additional dedicated matrix-multiplication units (\"matrix units\", \"tensor cores\"). [ 37 ] [ 38 ] It is therefore insufficient to simply qualify a GPU's computational capabilities in terms of FLOPS: FLOPS values should be separately presented for matrix vs non-matrix modes and (T)OPS figures should also be presented for integer operations. Energy efficiency The high performance of GPUs comes at the cost of high power consumption, which under full load is in fact as much power as the rest of the PC system combined. [ 39 ] The maximum power consumption of the Pascal series GPU (Tesla P100) was specified to be 250W. [ 40 ] In terms of raw computing power (FLOPS, TOPS, etc.), GPUs tend to have more performance-per-watt than a typical CPU. However, it takes a well-written program and a fitting workload to extract most of this power, as most of the time (and power) would otherwise be wasted on local and host memory access. Classical GPGPU Before CUDA was published in 2007, GPGPU was \"classical\" and involved repurposing graphics primitives. A standard structure of such was: Load arrays into textures Draw a quadrangle Apply pixel shaders and textures to quadrangle Read out pixel values in the quadrangle as array More examples are available in part 4 of GPU Gems 2 . [ 41 ] Linear algebra Using GPU for numerical linear algebra began at least in 2001. [ 42 ] It had been used for Gauss-Seidel solver, conjugate gradients, etc. [ 43 ] Hardware support Computer video cards are produced by various vendors, such as Nvidia , AMD . Cards from such vendors differ on implementing data-format support, such as integer and floating-point formats (32-bit and 64-bit). Microsoft introduced a Shader Model standard, to help rank the various features of graphic cards into a simple Shader Model version number (1.0, 2.0, 3.0, etc.). Integer numbers Pre-DirectX 9 video cards only supported paletted or integer color types. Sometimes another alpha value is added, to be used for transparency. Common formats are: 8 bits per pixel – Sometimes palette mode, where each value is an index in a table with the real color value specified in one of the other formats. Sometimes three bits for red, three bits for green, and two bits for blue. 16 bits per pixel – Usually the bits are allocated as five bits for red, six bits for green, and five bits for blue. 24 bits per pixel – There are eight bits for each of red, green, and blue. 32 bits per pixel – There are eight bits for each of red, green, blue, and alpha . Floating-point numbers For early fixed-function or limited programmability graphics (i.e., up to and including DirectX 8.1-compliant GPUs) this was sufficient because this is also the representation used in displays. This representation does have certain limitations. Given sufficient graphics processing power even graphics programmers would like to use better formats, such as floating point data formats, to obtain effects such as high-dynamic-range imaging . Many GPGPU applications require floating point accuracy, which came with video cards conforming to the DirectX 9 specification. DirectX 9 Shader Model 2.x suggested the support of two precision types: full and partial precision. Full precision support could either be FP32 or FP24 (floating point 32- or 24-bit per component) or greater, while partial precision was FP16. ATI's Radeon R300 series of GPUs supported FP24 precision only in the programmable fragment pipeline (although FP32 was supported in the vertex processors) while Nvidia 's NV30 series supported both FP16 and FP32; other vendors such as S3 Graphics and XGI supported a mixture of formats up to FP24. The implementations of floating point on Nvidia GPUs are mostly IEEE compliant; however, this is not true across all vendors. [ 44 ] This has implications for correctness which are considered important to some scientific applications. While 64-bit floating point values (double precision float) are commonly available on CPUs, these are not universally supported on GPUs. Some GPU architectures sacrifice IEEE compliance, while others lack double-precision. Efforts have occurred to emulate double-precision floating point values on GPUs; however, the speed tradeoff negates any benefit to offloading the computing onto the GPU in the first place. [ 45 ] Vectorization .mw-parser-output .hatnote{font-style:italic}.mw-parser-output div.hatnote{padding-left:1.6em;margin-bottom:0.5em}.mw-parser-output .hatnote i{font-style:normal}.mw-parser-output .hatnote+link+.hatnote{margin-top:-0.5em}@media print{body.ns-0 .mw-parser-output .hatnote{display:none!important}} See also: Vector_processor § GPU_vector_processing_features , SIMD , SWAR , and SIMT This section does not cite any sources . Please help improve this section by adding citations to reliable sources . Unsourced material may be challenged and removed . ( July 2017 ) ( Learn how and when to remove this message ) Most operations on the GPU operate in a vectorized fashion: one operation can be performed on up to four values at once. [ disputed – discuss ] For example, if one color ⟨ R1, G1, B1 ⟩ is to be modulated by another color ⟨ R2, G2, B2 ⟩ , the GPU can produce the resulting color ⟨ R1*R2, G1*G2, B1*B2 ⟩ in one operation. This functionality is useful in graphics because almost every basic data type is a vector (either 2-, 3-, or 4-dimensional). [ citation needed ] Examples include vertices, colors, normal vectors, and texture coordinates. Stream processing Main article: Stream processing GPUs are originally designed specifically for graphics and thus are very restrictive in operations and programming. Due to their design, GPUs are only effective for problems that can be solved using stream processing and the hardware can only be used in certain ways. In the early GPGPU age, GPUs can only process independent vertices and fragments, but can process many of them in parallel. This is especially effective when the programmer wants to process many vertices or fragments in the same way. In this sense, GPUs are stream processors – processors that can operate in parallel by running one kernel on many records in a stream at once. Programmers would use graphics APIs ( OpenGL or DirectX ) to perform general-purpose computation. With the introduction of the CUDA (Nvidia, 2007) and OpenCL (vendor-independent, 2008) general-purpose computing APIs, in new GPGPU codes it is no longer necessary to map the computation to graphics primitives. The stream processing nature of GPUs remains valid regardless of the APIs used. (See e.g., [ 46 ] ) A stream is simply a set of records that require similar computation. Streams provide data parallelism. Kernels are the functions that are applied to each element in the stream. In the GPUs, vertices and fragments are the elements in streams and vertex and fragment shaders are the kernels to be run on them. [ dubious – discuss ] For each element we can only read from the input, perform operations on it, and write to the output. It is permissible to have multiple inputs and multiple outputs, but never a piece of memory that is both readable and writable. [ vague ] Arithmetic intensity is defined as the number of operations performed per word of memory transferred. It is important for GPGPU applications to have high arithmetic intensity else the memory access latency will limit computational speedup. [ 47 ] Ideal GPGPU applications have large data sets, high parallelism, and minimal dependency between data elements. GPU programming concepts Computational resources There are a variety of computational resources available on the GPU: Programmable processors – vertex, primitive, fragment and mainly compute pipelines allow programmer to perform kernel on streams of data Rasterizer – creates fragments and interpolates per-vertex constants such as texture coordinates and color Texture unit – read-only memory interface Framebuffer – write-only memory interface In fact, a program can substitute a write only texture for output instead of the framebuffer. This is done either through Render to Texture (RTT), Render-To-Backbuffer-Copy-To-Texture (RTBCTT), or the more recent stream-out. Textures as stream The most common form for a stream to take in GPGPU is a 2D grid because this fits naturally with the rendering model built into GPUs. Many computations naturally map into grids: matrix algebra, image processing, physically based simulation, and so on. Since textures are used as memory, texture lookups are then used as memory reads. Certain operations can be done automatically by the GPU because of this. Kernels Compute kernels can be thought of as the body of loops . For example, a programmer operating on a grid on the CPU might have code that looks like this: // Input and output grids have 10000 x 10000 or 100 million elements. void transform_10k_by_10k_grid ( float in [ 10000 ][ 10000 ], float out [ 10000 ][ 10000 ]) { for ( int x = 0 ; x &lt; 10000 ; x ++ ) { for ( int y = 0 ; y &lt; 10000 ; y ++ ) { // The next line is executed 100 million times out [ x ][ y ] = do_some_hard_work ( in [ x ][ y ]); } } } On the GPU, the programmer only specifies the body of the loop as the kernel and what data to loop over by invoking geometry processing. Flow control For accurate technical information on this topic see Predication_(computer_architecture)#SIMD,_SIMT_and_vector_predication and ILLIAC IV \"branching\" (the term \"predicate mask\" did not exist in 1967). In sequential code it is possible to control the flow of the program using if-then-else statements and various forms of loops. Such flow control structures have only recently been added to GPUs. [ 48 ] Conditional writes could be performed using a properly crafted series of arithmetic/bit operations, but looping and conditional branching were not possible. Recent [ when? ] GPUs allow branching, but usually with a performance penalty. Branching should generally be avoided in inner loops, whether in CPU or GPU code, and various methods, such as static branch resolution, pre-computation, predication, loop splitting, [ 49 ] and Z-cull [ 50 ] can be used to achieve branching when hardware support does not exist. GPU methods Map Main article: Map (parallel pattern) The map operation simply applies the given function (the kernel) to every element in the stream. A simple example is multiplying each value in the stream by a constant (increasing the brightness of an image). The map operation is simple to implement on the GPU. The programmer generates a fragment for each pixel on screen and applies a fragment program to each one. The result stream of the same size is stored in the output buffer. Reduce Main article: Fold (higher-order function) Some computations require calculating a smaller stream (possibly a stream of only one element) from a larger stream. This is called a reduction of the stream. Generally, a reduction can be performed in multiple steps. The results from the prior step are used as the input for the current step and the range over which the operation is applied is reduced until only one stream element remains. Stream filtering Stream filtering is essentially a non-uniform reduction. Filtering involves removing items from the stream based on some criteria. Scan The scan operation, also termed parallel prefix sum , takes in a vector (stream) of data elements and an (arbitrary) associative binary function '+' with an identity element 'i' . If the input is [a0, a1, a2, a3, ...], an exclusive scan produces the output [i, a0, a0 + a1, a0 + a1 + a2, ...], while an inclusive scan produces the output [a0, a0 + a1, a0 + a1 + a2, a0 + a1 + a2 + a3, ...] and does not require an identity to exist. While at first glance the operation may seem inherently serial, efficient parallel scan algorithms are possible and have been implemented on graphics processing units. The scan operation has uses in e.g., quicksort and sparse matrix-vector multiplication. [ 46 ] [ 51 ] [ 52 ] [ 53 ] Scatter The scatter operation is most naturally defined on the vertex processor. The vertex processor is able to adjust the position of the vertex , which allows the programmer to control where information is deposited on the grid. Other extensions are also possible, such as controlling how large an area the vertex affects. The fragment processor cannot perform a direct scatter operation because the location of each fragment on the grid is fixed at the time of the fragment's creation and cannot be altered by the programmer. However, a logical scatter operation may sometimes be recast or implemented with another gather step. A scatter implementation would first emit both an output value and an output address. An immediately following gather operation uses address comparisons to see whether the output value maps to the current output slot. In dedicated compute kernels , scatter can be performed by indexed writes. Gather Gather is the reverse of scatter. After scatter reorders elements according to a map, gather can restore the order of the elements according to the map scatter used. In dedicated compute kernels, gather may be performed by indexed reads. In other shaders, it is performed with texture-lookups. Sort The sort operation transforms an unordered set of elements into an ordered set of elements. The most common implementation on GPUs is using radix sort for integer and floating point data and coarse-grained merge sort and fine-grained sorting networks for general comparable data. [ 54 ] [ 55 ] Search The search operation allows the programmer to find a given element within the stream, or possibly find neighbors of a specified element. Mostly the search method used is binary search on sorted elements. Data structures A variety of data structures can be represented on the GPU: Dense arrays Sparse matrices ( sparse array ) – static or dynamic Adaptive structures ( union type ) Applications The following are some of the areas where GPUs have been used for general purpose computing: Automatic parallelization [ 56 ] [ 57 ] [ 58 ] Physical based simulation and physics engines [ 25 ] (usually based on Newtonian physics models) Conway's Game of Life , cloth simulation , fluid incompressible flow by solution of Euler equations (fluid dynamics) [ 59 ] or Navier–Stokes equations [ 60 ] Statistical physics Ising model [ 61 ] Lattice gauge theory [ 62 ] Segmentation – 2D and 3D [ 63 ] Level set methods CT reconstruction [ 64 ] Fast Fourier transform [ 65 ] GPU learning – machine learning and data mining computations, e.g., with software BIDMach k-nearest neighbor algorithm [ 66 ] Fuzzy logic [ 67 ] Tone mapping Audio signal processing [ 68 ] Audio and sound effects processing, to use a GPU for digital signal processing (DSP) Analog signal processing Speech processing Digital image processing Video processing [ 69 ] Hardware accelerated video decoding and post-processing Motion compensation (mo comp) Inverse discrete cosine transform (iDCT) Variable-length decoding (VLD), Huffman coding Inverse quantization (IQ, not to be confused with Intelligence Quotient ) In-loop deblocking Bitstream processing ( CAVLC / CABAC ) using special purpose hardware for this task because this is a serial task not suitable for regular GPGPU computation Deinterlacing Spatial-temporal deinterlacing Noise reduction Edge enhancement Color correction Hardware accelerated video encoding and pre-processing Global illumination – ray tracing , photon mapping , radiosity among others, subsurface scattering Geometric computing – constructive solid geometry , distance fields, collision detection , transparency computation, shadow generation Scientific computing Monte Carlo simulation of light propagation [ 70 ] Weather forecasting Climate research Molecular modeling on GPU [ 71 ] Quantum mechanical physics Astrophysics [ 72 ] Number theory Primality testing and integer factorization [ 73 ] Bioinformatics [ 74 ] [ 75 ] Medical imaging Clinical decision support system (CDSS) [ 76 ] Computer vision [ 77 ] Digital signal processing / signal processing Control engineering [ citation needed ] Operations research [ 78 ] [ 79 ] [ 80 ] Implementations of: the GPU Tabu Search algorithm solving the Resource Constrained Project Scheduling problem is freely available on GitHub; [ 81 ] the GPU algorithm solving the Nurse scheduling problem is freely available on GitHub. [ 82 ] Neural networks Database operations [ 83 ] Computational Fluid Dynamics especially using Lattice Boltzmann methods Cryptography [ 84 ] and cryptanalysis Performance modeling: computationally intensive tasks on GPU [ 71 ] Implementations of: MD6 , Advanced Encryption Standard (AES), [ 85 ] [ 86 ] Data Encryption Standard (DES), RSA , [ 87 ] elliptic curve cryptography (ECC) Password cracking [ 88 ] [ 89 ] Cryptocurrency transactions processing (\"mining\") ( Bitcoin mining ) Electronic design automation [ 90 ] [ 91 ] Antivirus software [ 92 ] [ 93 ] Intrusion detection [ 94 ] [ 95 ] Increase computing power for distributed computing projects like SETI@home , Einstein@home Bioinformatics GPGPU usage in Bioinformatics: [ 71 ] [ 96 ] Application Description Supported features Expected speed-up† GPU‡ Multi-GPU support Release status BarraCUDA DNA, including epigenetics, sequence mapping software [ 97 ] Alignment of short sequencing reads 6–10x T 2075, 2090, K10, K20, K20X Yes Available now, version 0.7.107f CUDASW++ Open source software for Smith-Waterman protein database searches on GPUs Parallel search of Smith-Waterman database 10–50x T 2075, 2090, K10, K20, K20X Yes Available now, version 2.0.8 CUSHAW Parallelized short read aligner Parallel, accurate long read aligner – gapped alignments to large genomes 10x T 2075, 2090, K10, K20, K20X Yes Available now, version 1.0.40 GPU-BLAST Local search with fast k -tuple heuristic Protein alignment according to blastp, multi CPU threads 3–4x T 2075, 2090, K10, K20, K20X Single only Available now, version 2.2.26 GPU-HMMER Parallelized local and global search with profile hidden Markov models Parallel local and global search of hidden Markov models 60–100x T 2075, 2090, K10, K20, K20X Yes Available now, version 2.3.2 mCUDA-MEME Ultrafast scalable motif discovery algorithm based on MEME Scalable motif discovery algorithm based on MEME 4–10x T 2075, 2090, K10, K20, K20X Yes Available now, version 3.0.12 SeqNFind A GPU accelerated sequence analysis toolset Reference assembly, blast, Smith–Waterman, hmm, de novo assembly 400x T 2075, 2090, K10, K20, K20X Yes Available now UGENE Opensource Smith–Waterman for SSE/CUDA, suffix array based repeats finder and dotplot Fast short read alignment 6–8x T 2075, 2090, K10, K20, K20X Yes Available now, version 1.11 WideLM Fits numerous linear models to a fixed design and response Parallel linear regression on multiple similarly-shaped models 150x T 2075, 2090, K10, K20, K20X Yes Available now, version 0.1-1 Molecular dynamics Further information: Molecular modeling on GPUs and Comparison of software for molecular mechanics modeling Application Description Supported features Expected speed-up† GPU‡ Multi-GPU support Release status Abalone Models molecular dynamics of biopolymers for simulations of proteins, DNA and ligands Explicit and implicit solvent, hybrid Monte Carlo 4–120x T 2075, 2090, K10, K20, K20X Single only Available now, version 1.8.88 ACEMD GPU simulation of molecular mechanics force fields, implicit and explicit solvent Written for use on GPUs 160 ns/day GPU version only T 2075, 2090, K10, K20, K20X Yes Available now AMBER Suite of programs to simulate molecular dynamics on biomolecule PMEMD: explicit and implicit solvent 89.44 ns/day JAC NVE T 2075, 2090, K10, K20, K20X Yes Available now, version 12 + bugfix9 DL-POLY Simulate macromolecules, polymers, ionic systems, etc. on a distributed memory parallel computer Two-body forces, link-cell pairs, Ewald SPME forces, Shake VV 4x T 2075, 2090, K10, K20, K20X Yes Available now, version 4.0 source only CHARMM MD package to simulate molecular dynamics on biomolecule. Implicit (5x), explicit (2x) solvent via OpenMM TBD T 2075, 2090, K10, K20, K20X Yes In development Q4/12 GROMACS Simulate biochemical molecules with complex bond interactions Implicit (5x), explicit (2x) solvent 165 ns/Day DHFR T 2075, 2090, K10, K20, K20X Single only Available now, version 4.6 in Q4/12 HOOMD-Blue Particle dynamics package written grounds up for GPUs Written for GPUs 2x T 2075, 2090, K10, K20, K20X Yes Available now LAMMPS Classical molecular dynamics package Lennard-Jones, Morse, Buckingham, CHARMM, tabulated, course grain SDK, anisotropic Gay-Bern, RE-squared, \"hybrid\" combinations 3–18x T 2075, 2090, K10, K20, K20X Yes Available now NAMD Designed for high-performance simulation of large molecular systems 100M atom capable 6.44 ns/days STMV 585x 2050s T 2075, 2090, K10, K20, K20X Yes Available now, version 2.9 OpenMM Library and application for molecular dynamics for HPC with GPUs Implicit and explicit solvent, custom forces Implicit: 127–213 ns/day; Explicit: 18–55 ns/day DHFR T 2075, 2090, K10, K20, K20X Yes Available now, version 4.1.1 † Expected speedups are highly dependent on system configuration. GPU performance compared against multi-core x86 CPU socket. GPU performance benchmarked on GPU supported features and may be a kernel to kernel performance comparison. For details on configuration used, view application website. Speedups as per Nvidia in-house testing or ISV's documentation. ‡ Q= Quadro GPU , T= Tesla GPU . Nvidia recommended GPUs for this application. Check with developer or ISV to obtain certification information. See also AI accelerator Audio processing unit Close to Metal Deep learning processor (DLP) Fastra II Larrabee (microarchitecture) Physics engine Advanced Simulation Library Physics processing unit (PPU) Vector processor – Computer processor which works on arrays of several numbers at once Single instruction, multiple threads – Parallel computing execution model References .mw-parser-output .reflist{margin-bottom:0.5em;list-style-type:decimal}@media screen{.mw-parser-output .reflist{font-size:90%}}.mw-parser-output .reflist .references{font-size:100%;margin-bottom:0;list-style-type:inherit}.mw-parser-output .reflist-columns-2{column-width:30em}.mw-parser-output .reflist-columns-3{column-width:25em}.mw-parser-output .reflist-columns{margin-top:0.3em}.mw-parser-output .reflist-columns ol{margin-top:0}.mw-parser-output .reflist-columns li{page-break-inside:avoid;break-inside:avoid-column}.mw-parser-output .reflist-upper-alpha{list-style-type:upper-alpha}.mw-parser-output .reflist-upper-roman{list-style-type:upper-roman}.mw-parser-output .reflist-lower-alpha{list-style-type:lower-alpha}.mw-parser-output .reflist-lower-greek{list-style-type:lower-greek}.mw-parser-output .reflist-lower-roman{list-style-type:lower-roman} ↑ .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:\"\\\"\"\"\\\"\"\"'\"\"'\"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free.id-lock-free a{background:url(\"//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg\")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited.id-lock-limited a,.mw-parser-output .id-lock-registration.id-lock-registration a{background:url(\"//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg\")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription.id-lock-subscription a{background:url(\"//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg\")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:url(\"//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg\")right 0.1em center/12px no-repeat}body:not(.skin-timeless):not(.skin-minerva) .mw-parser-output .id-lock-free a,body:not(.skin-timeless):not(.skin-minerva) .mw-parser-output .id-lock-limited a,body:not(.skin-timeless):not(.skin-minerva) .mw-parser-output .id-lock-registration a,body:not(.skin-timeless):not(.skin-minerva) .mw-parser-output .id-lock-subscription a,body:not(.skin-timeless):not(.skin-minerva) .mw-parser-output .cs1-ws-icon a{background-size:contain;padding:0 1em 0 0}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:var(--color-error,#d33)}.mw-parser-output .cs1-visible-error{color:var(--color-error,#d33)}.mw-parser-output .cs1-maint{display:none;color:#085;margin-left:0.3em}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}@media screen{.mw-parser-output .cs1-format{font-size:95%}html.skin-theme-clientpref-night .mw-parser-output .cs1-maint{color:#18911f}}@media screen and (prefers-color-scheme:dark){html.skin-theme-clientpref-os .mw-parser-output .cs1-maint{color:#18911f}} Fung, James; Tang, Felix; Mann, Steve (7–10 October 2002). Mediated Reality Using Computer Graphics Hardware for Computer Vision (PDF) . Proceedings of the International Symposium on Wearable Computing 2002 (ISWC2002). Seattle, Washington, USA. pp. 83– 89. Archived from the original (PDF) on 2 April 2012. ↑ Aimone, Chris; Fung, James; Mann, Steve (2003). \"An Eye Tap video-based featureless projective motion estimation assisted by gyroscopic tracking for wearable computer mediated reality\" . Personal and Ubiquitous Computing . 7 (5): 236– 248. doi : 10.1007/s00779-003-0239-6 . S2CID 25168728 . ↑ \"Computer Vision Signal Processing on Graphics Processing Units\", Proceedings of the IEEE International Conference on Acoustics, Speech, and Signal Processing (ICASSP 2004) Archived 19 August 2011 at the Wayback Machine : Montreal, Quebec, Canada, 17–21 May 2004, pp. V-93 – V-96 ↑ Chitty, D. M. (2007, July). A data parallel approach to genetic programming using programmable graphics hardware Archived 8 August 2017 at the Wayback Machine . In Proceedings of the 9th annual conference on Genetic and evolutionary computation (pp. 1566-1573). ACM. ↑ \"Using Multiple Graphics Cards as a General Purpose Parallel Computer: Applications to Computer Vision\", Proceedings of the 17th International Conference on Pattern Recognition (ICPR2004) Archived 18 July 2011 at the Wayback Machine , Cambridge, United Kingdom, 23–26 August 2004, volume 1, pages 805–808. ↑ Hull, Gerald (December 1987). \"LIFE\" . Amazing Computing . 2 (12): 81– 84. ↑ Krüger, Jens; Westermann, Rüdiger (July 2003). \"Linear algebra operators for GPU implementation of numerical algorithms\" . ACM Transactions on Graphics . 22 (3): 908– 916. doi : 10.1145/882262.882363 . ISSN 0730-0301 . ↑ Bolz, Jeff; Farmer, Ian; Grinspun, Eitan; Schröder, Peter (July 2003). \"Sparse matrix solvers on the GPU: conjugate gradients and multigrid\" . ACM Transactions on Graphics . 22 (3): 917– 924. doi : 10.1145/882262.882364 . ISSN 0730-0301 . ↑ Tarditi, David; Puri, Sidd; Oglesby, Jose (2006). \"Accelerator: using data parallelism to program GPUs for general-purpose uses\" (PDF) . ACM SIGARCH Computer Architecture News . 34 (5). doi : 10.1145/1168919.1168898 . ↑ Che, Shuai; Boyer, Michael; Meng, Jiayuan; Tarjan, D.; Sheaffer, Jeremy W.; Skadron, Kevin (2008). \"A performance study of general-purpose applications on graphics processors using CUDA\". J. Parallel and Distributed Computing . 68 (10): 1370– 1380. CiteSeerX 10.1.1.143.4849 . doi : 10.1016/j.jpdc.2008.05.014 . ↑ Glaser, J.; Nguyen, T. D.; Anderson, J. A.; Lui, P.; Spiga, F.; Millan, J. A.; Morse, D. C.; Glotzer, S. C. (2015). \"Strong scaling of general-purpose molecular dynamics simulations on GPUs\" . Computer Physics Communications . 192 : 97– 107. arXiv : 1412.3387 . Bibcode : 2015CoPhC.192...97G . doi : 10.1016/j.cpc.2015.02.028 . 1 2 Du, Peng; Weber, Rick; Luszczek, Piotr; Tomov, Stanimire; Peterson, Gregory; Dongarra, Jack (2012). \"From CUDA to OpenCL: Towards a performance-portable solution for multi-platform GPU programming\". Parallel Computing . 38 (8): 391– 407. CiteSeerX 10.1.1.193.7712 . doi : 10.1016/j.parco.2011.10.002 . ↑ Harris, Mark (25 January 2017). \"An Even Easier Introduction to CUDA\" . Nvidia . Retrieved 16 February 2025 . ↑ \"OpenCL Gains Ground on CUDA\" . 28 February 2012. Archived from the original on 23 April 2012 . Retrieved 10 April 2012 . \"As the two major programming frameworks for GPU computing, OpenCL and CUDA have been competing for mindshare in the developer community for the past few years.\" ↑ Fung, James; Mann, Steve ; Aimone, Chris (6–11 November 2005). \"OpenVIDIA: Parallel GPU computer vision\" (PDF) . Proceedings of the 13th annual ACM international conference on Multimedia . Singapore: Association for Computing Machinery (published 6 November 2005). pp. 849– 852. doi : 10.1145/1101149.1101334 . ISBN 1595930442 . Archived from the original (PDF) on 23 December 2019 . Retrieved 18 March 2025 . ↑ \"Hybridizer\" . Hybridizer . Archived from the original on 17 October 2017. ↑ \"Home page\" . Altimesh . Archived from the original on 17 October 2017. ↑ \"Hybridizer generics and inheritance\" . 27 July 2017. Archived from the original on 17 October 2017. ↑ \"Debugging and Profiling with Hybridizer\" . 5 June 2017. Archived from the original on 17 October 2017. ↑ \"Introduction\" . Alea GPU . Archived from the original on 25 December 2016 . Retrieved 15 December 2016 . ↑ \"Home page\" . Quant Alea . Archived from the original on 12 December 2016 . Retrieved 15 December 2016 . ↑ \"Use F# for GPU Programming\" . F# Software Foundation. Archived from the original on 18 December 2016 . Retrieved 15 December 2016 . ↑ \"Alea GPU Features\" . Quant Alea . Archived from the original on 21 December 2016 . Retrieved 15 December 2016 . ↑ \"MATLAB Adds GPGPU Support\" . 20 September 2010. Archived from the original on 27 September 2010. 1 2 Joselli, Mark; Clua, Esteban; Montenegro, Anselmo; Conci, Aura; Pagliosa, Paulo (2008). \"A new physics engine with automatic process distribution between CPU-GPU\" . Proceedings of the 2008 ACM SIGGRAPH symposium on Video games . pp. 149– 156. doi : 10.1145/1401843.1401871 . ISBN 978-1-60558-173-6 . ↑ \"Android 4.2 APIs - Android Developers\" . developer.android.com . Archived from the original on 26 August 2013. ↑ \"Migrate scripts to OpenGL ES 3.1\" . ↑ \"Migrate scripts to Vulkan\" . ↑ McIntosh-Smith, Simon (15 July 2020). \"Catching Up with Khronos: Experts' Q&amp;A on OpenCL 3.0 and SYCL 2020\" . The Khronos Group . Retrieved 16 February 2025 . ↑ \"Nvidia-Kepler-GK110-Architecture-Whitepaper\" (PDF) . Archived (PDF) from the original on 21 February 2015. ↑ \" Inside Pascal: Nvidia’s Newest Computing Platform Archived 7 May 2017 at the Wayback Machine \" ↑ \" Inside Volta: The World’s Most Advanced Data Center GPU Archived 1 January 2020 at the Wayback Machine \" ↑ Li, Jie; Michelogiannakis, George; Cook, Brandon; Cooray, Dulanya; Chen, Yong (2023). \"Analyzing Resource Utilization in an HPC System: A Case Study of NERSC's Perlmutter\" . High Performance Computing . Lecture Notes in Computer Science. Vol. 13948. pp. 297– 316. doi : 10.1007/978-3-031-32041-5_16 . ISBN 978-3-031-32040-8 . ↑ \"OpenCL Best Practices Guide\" (PDF) . Nvidia . 2011. ↑ Lam, Chester. \"AMD's Zen 4 Part 1: Frontend and Execution Engine\" . chipsandcheese.com . ↑ \"CUDA C++ Programming Guide — CUDA C++ Programming Guide\" . docs.nvidia.com . ↑ Lam, Chester. \"AMD's CDNA 3 Compute Architecture\" . chipsandcheese.com . ↑ Lam, Chester. \"AMD's Radeon Instinct MI210: GCN Lives On\" . chipsandcheese.com . ↑ \" https://www.tomshardware.com/reviews/geforce-radeon-power,2122.html How Much Power Does Your Graphics Card Need?\" ↑ \" https://images.nvidia.com/content/tesla/pdf/nvidia-tesla-p100-PCIe-datasheet.pdf Nvidia Tesla P100 GPU Accelerator Archived 24 July 2018 at the Wayback Machine \" ↑ Pharr, Matt, ed. (2006). \"Part IV: General-Purpose Computation on GPUS: A Primer\" . GPU gems 2: programming techniques for high-performance graphics and general-purpose computation (3. print ed.). Upper Saddle River, NJ Munich: Addison-Wesley. ISBN 978-0-321-33559-3 . ↑ Larsen, E. Scott; McAllister, David (10 November 2001). \"Fast matrix multiplies using graphics hardware\" . Proceedings of the 2001 ACM/IEEE conference on Supercomputing . ACM. p. 55. doi : 10.1145/582034.582089 . ISBN 978-1-58113-293-9 . ↑ Krüger, Jens; Westermann, Rüdiger (2005). \"Linear algebra operators for GPU implementation of numerical algorithms\" . ACM SIGGRAPH 2005 Courses on - SIGGRAPH '05 . ACM Press. p. 234. doi : 10.1145/1198555.1198795 . ↑ Harris, Mark (2005). \"Mapping computational concepts to GPUs\" . ACM SIGGRAPH 2005 Courses on - SIGGRAPH '05 . pp. 50–es. doi : 10.1145/1198555.1198768 . ISBN 9781450378338 . S2CID 8212423 . ↑ Double precision on GPUs (Proceedings of ASIM 2005) Archived 21 August 2014 at the Wayback Machine : Dominik Goddeke, Robert Strzodka, and Stefan Turek. Accelerating Double Precision (FEM) Simulations with (GPUs). Proceedings of ASIM 2005 – 18th Symposium on Simulation Technique, 2005. 1 2 \"D. Göddeke, 2010. Fast and Accurate Finite-Element Multigrid Solvers for PDE Simulations on GPU Clusters. Ph.D. dissertation, Technischen Universität Dortmund\" . Archived from the original on 16 December 2014. ↑ Asanovic, K.; Bodik, R.; Demmel, J. ; Keaveny, T.; Keutzer, K.; Kubiatowicz, J.; Morgan, N.; Patterson, D.; Sen, K.; Wawrzynek, J.; Wessel, D.; Yelick, K. (2009). \"A view of the parallel computing landscape\" . Commun. ACM . 52 (10): 56– 67. doi : 10.1145/1562764.1562783 . ↑ \"GPU Gems – Chapter 34, GPU Flow-Control Idioms\" . ↑ Future Chips . \"Tutorial on removing branches\", 2011 ↑ GPGPU survey paper Archived 4 January 2007 at the Wayback Machine : John D. Owens, David Luebke, Naga Govindaraju, Mark Harris, Jens Krüger, Aaron E. Lefohn, and Tim Purcell. \"A Survey of G",
  "cached_at": "2025-10-25T19:36:18.938811"
}